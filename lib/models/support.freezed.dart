// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'support.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$UriCacheInfo {
  Uri get uri => throw _privateConstructorUsedError;
  String get cacheKey => throw _privateConstructorUsedError;
  CacheManager get cacheManager => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $UriCacheInfoCopyWith<UriCacheInfo> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UriCacheInfoCopyWith<$Res> {
  factory $UriCacheInfoCopyWith(
          UriCacheInfo value, $Res Function(UriCacheInfo) then) =
      _$UriCacheInfoCopyWithImpl<$Res, UriCacheInfo>;
  @useResult
  $Res call({Uri uri, String cacheKey, CacheManager cacheManager});
}

/// @nodoc
class _$UriCacheInfoCopyWithImpl<$Res, $Val extends UriCacheInfo>
    implements $UriCacheInfoCopyWith<$Res> {
  _$UriCacheInfoCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? uri = null,
    Object? cacheKey = null,
    Object? cacheManager = null,
  }) {
    return _then(_value.copyWith(
      uri: null == uri
          ? _value.uri
          : uri // ignore: cast_nullable_to_non_nullable
              as Uri,
      cacheKey: null == cacheKey
          ? _value.cacheKey
          : cacheKey // ignore: cast_nullable_to_non_nullable
              as String,
      cacheManager: null == cacheManager
          ? _value.cacheManager
          : cacheManager // ignore: cast_nullable_to_non_nullable
              as CacheManager,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_UriCacheInfoCopyWith<$Res>
    implements $UriCacheInfoCopyWith<$Res> {
  factory _$$_UriCacheInfoCopyWith(
          _$_UriCacheInfo value, $Res Function(_$_UriCacheInfo) then) =
      __$$_UriCacheInfoCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({Uri uri, String cacheKey, CacheManager cacheManager});
}

/// @nodoc
class __$$_UriCacheInfoCopyWithImpl<$Res>
    extends _$UriCacheInfoCopyWithImpl<$Res, _$_UriCacheInfo>
    implements _$$_UriCacheInfoCopyWith<$Res> {
  __$$_UriCacheInfoCopyWithImpl(
      _$_UriCacheInfo _value, $Res Function(_$_UriCacheInfo) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? uri = null,
    Object? cacheKey = null,
    Object? cacheManager = null,
  }) {
    return _then(_$_UriCacheInfo(
      uri: null == uri
          ? _value.uri
          : uri // ignore: cast_nullable_to_non_nullable
              as Uri,
      cacheKey: null == cacheKey
          ? _value.cacheKey
          : cacheKey // ignore: cast_nullable_to_non_nullable
              as String,
      cacheManager: null == cacheManager
          ? _value.cacheManager
          : cacheManager // ignore: cast_nullable_to_non_nullable
              as CacheManager,
    ));
  }
}

/// @nodoc

class _$_UriCacheInfo implements _UriCacheInfo {
  const _$_UriCacheInfo(
      {required this.uri, required this.cacheKey, required this.cacheManager});

  @override
  final Uri uri;
  @override
  final String cacheKey;
  @override
  final CacheManager cacheManager;

  @override
  String toString() {
    return 'UriCacheInfo(uri: $uri, cacheKey: $cacheKey, cacheManager: $cacheManager)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UriCacheInfo &&
            (identical(other.uri, uri) || other.uri == uri) &&
            (identical(other.cacheKey, cacheKey) ||
                other.cacheKey == cacheKey) &&
            (identical(other.cacheManager, cacheManager) ||
                other.cacheManager == cacheManager));
  }

  @override
  int get hashCode => Object.hash(runtimeType, uri, cacheKey, cacheManager);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_UriCacheInfoCopyWith<_$_UriCacheInfo> get copyWith =>
      __$$_UriCacheInfoCopyWithImpl<_$_UriCacheInfo>(this, _$identity);
}

abstract class _UriCacheInfo implements UriCacheInfo {
  const factory _UriCacheInfo(
      {required final Uri uri,
      required final String cacheKey,
      required final CacheManager cacheManager}) = _$_UriCacheInfo;

  @override
  Uri get uri;
  @override
  String get cacheKey;
  @override
  CacheManager get cacheManager;
  @override
  @JsonKey(ignore: true)
  _$$_UriCacheInfoCopyWith<_$_UriCacheInfo> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$CacheInfo {
  String get cacheKey => throw _privateConstructorUsedError;
  CacheManager get cacheManager => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $CacheInfoCopyWith<CacheInfo> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CacheInfoCopyWith<$Res> {
  factory $CacheInfoCopyWith(CacheInfo value, $Res Function(CacheInfo) then) =
      _$CacheInfoCopyWithImpl<$Res, CacheInfo>;
  @useResult
  $Res call({String cacheKey, CacheManager cacheManager});
}

/// @nodoc
class _$CacheInfoCopyWithImpl<$Res, $Val extends CacheInfo>
    implements $CacheInfoCopyWith<$Res> {
  _$CacheInfoCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? cacheKey = null,
    Object? cacheManager = null,
  }) {
    return _then(_value.copyWith(
      cacheKey: null == cacheKey
          ? _value.cacheKey
          : cacheKey // ignore: cast_nullable_to_non_nullable
              as String,
      cacheManager: null == cacheManager
          ? _value.cacheManager
          : cacheManager // ignore: cast_nullable_to_non_nullable
              as CacheManager,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_CacheInfoCopyWith<$Res> implements $CacheInfoCopyWith<$Res> {
  factory _$$_CacheInfoCopyWith(
          _$_CacheInfo value, $Res Function(_$_CacheInfo) then) =
      __$$_CacheInfoCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String cacheKey, CacheManager cacheManager});
}

/// @nodoc
class __$$_CacheInfoCopyWithImpl<$Res>
    extends _$CacheInfoCopyWithImpl<$Res, _$_CacheInfo>
    implements _$$_CacheInfoCopyWith<$Res> {
  __$$_CacheInfoCopyWithImpl(
      _$_CacheInfo _value, $Res Function(_$_CacheInfo) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? cacheKey = null,
    Object? cacheManager = null,
  }) {
    return _then(_$_CacheInfo(
      cacheKey: null == cacheKey
          ? _value.cacheKey
          : cacheKey // ignore: cast_nullable_to_non_nullable
              as String,
      cacheManager: null == cacheManager
          ? _value.cacheManager
          : cacheManager // ignore: cast_nullable_to_non_nullable
              as CacheManager,
    ));
  }
}

/// @nodoc

class _$_CacheInfo implements _CacheInfo {
  const _$_CacheInfo({required this.cacheKey, required this.cacheManager});

  @override
  final String cacheKey;
  @override
  final CacheManager cacheManager;

  @override
  String toString() {
    return 'CacheInfo(cacheKey: $cacheKey, cacheManager: $cacheManager)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_CacheInfo &&
            (identical(other.cacheKey, cacheKey) ||
                other.cacheKey == cacheKey) &&
            (identical(other.cacheManager, cacheManager) ||
                other.cacheManager == cacheManager));
  }

  @override
  int get hashCode => Object.hash(runtimeType, cacheKey, cacheManager);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_CacheInfoCopyWith<_$_CacheInfo> get copyWith =>
      __$$_CacheInfoCopyWithImpl<_$_CacheInfo>(this, _$identity);
}

abstract class _CacheInfo implements CacheInfo {
  const factory _CacheInfo(
      {required final String cacheKey,
      required final CacheManager cacheManager}) = _$_CacheInfo;

  @override
  String get cacheKey;
  @override
  CacheManager get cacheManager;
  @override
  @JsonKey(ignore: true)
  _$$_CacheInfoCopyWith<_$_CacheInfo> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$Palette {
  PaletteColor? get vibrantColor => throw _privateConstructorUsedError;
  PaletteColor? get dominantColor => throw _privateConstructorUsedError;
  PaletteColor? get mutedColor => throw _privateConstructorUsedError;
  PaletteColor? get darkMutedColor => throw _privateConstructorUsedError;
  PaletteColor? get darkVibrantColor => throw _privateConstructorUsedError;
  PaletteColor? get lightMutedColor => throw _privateConstructorUsedError;
  PaletteColor? get lightVibrantColor => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $PaletteCopyWith<Palette> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PaletteCopyWith<$Res> {
  factory $PaletteCopyWith(Palette value, $Res Function(Palette) then) =
      _$PaletteCopyWithImpl<$Res, Palette>;
  @useResult
  $Res call(
      {PaletteColor? vibrantColor,
      PaletteColor? dominantColor,
      PaletteColor? mutedColor,
      PaletteColor? darkMutedColor,
      PaletteColor? darkVibrantColor,
      PaletteColor? lightMutedColor,
      PaletteColor? lightVibrantColor});
}

/// @nodoc
class _$PaletteCopyWithImpl<$Res, $Val extends Palette>
    implements $PaletteCopyWith<$Res> {
  _$PaletteCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? vibrantColor = freezed,
    Object? dominantColor = freezed,
    Object? mutedColor = freezed,
    Object? darkMutedColor = freezed,
    Object? darkVibrantColor = freezed,
    Object? lightMutedColor = freezed,
    Object? lightVibrantColor = freezed,
  }) {
    return _then(_value.copyWith(
      vibrantColor: freezed == vibrantColor
          ? _value.vibrantColor
          : vibrantColor // ignore: cast_nullable_to_non_nullable
              as PaletteColor?,
      dominantColor: freezed == dominantColor
          ? _value.dominantColor
          : dominantColor // ignore: cast_nullable_to_non_nullable
              as PaletteColor?,
      mutedColor: freezed == mutedColor
          ? _value.mutedColor
          : mutedColor // ignore: cast_nullable_to_non_nullable
              as PaletteColor?,
      darkMutedColor: freezed == darkMutedColor
          ? _value.darkMutedColor
          : darkMutedColor // ignore: cast_nullable_to_non_nullable
              as PaletteColor?,
      darkVibrantColor: freezed == darkVibrantColor
          ? _value.darkVibrantColor
          : darkVibrantColor // ignore: cast_nullable_to_non_nullable
              as PaletteColor?,
      lightMutedColor: freezed == lightMutedColor
          ? _value.lightMutedColor
          : lightMutedColor // ignore: cast_nullable_to_non_nullable
              as PaletteColor?,
      lightVibrantColor: freezed == lightVibrantColor
          ? _value.lightVibrantColor
          : lightVibrantColor // ignore: cast_nullable_to_non_nullable
              as PaletteColor?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_PaletteCopyWith<$Res> implements $PaletteCopyWith<$Res> {
  factory _$$_PaletteCopyWith(
          _$_Palette value, $Res Function(_$_Palette) then) =
      __$$_PaletteCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {PaletteColor? vibrantColor,
      PaletteColor? dominantColor,
      PaletteColor? mutedColor,
      PaletteColor? darkMutedColor,
      PaletteColor? darkVibrantColor,
      PaletteColor? lightMutedColor,
      PaletteColor? lightVibrantColor});
}

/// @nodoc
class __$$_PaletteCopyWithImpl<$Res>
    extends _$PaletteCopyWithImpl<$Res, _$_Palette>
    implements _$$_PaletteCopyWith<$Res> {
  __$$_PaletteCopyWithImpl(_$_Palette _value, $Res Function(_$_Palette) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? vibrantColor = freezed,
    Object? dominantColor = freezed,
    Object? mutedColor = freezed,
    Object? darkMutedColor = freezed,
    Object? darkVibrantColor = freezed,
    Object? lightMutedColor = freezed,
    Object? lightVibrantColor = freezed,
  }) {
    return _then(_$_Palette(
      vibrantColor: freezed == vibrantColor
          ? _value.vibrantColor
          : vibrantColor // ignore: cast_nullable_to_non_nullable
              as PaletteColor?,
      dominantColor: freezed == dominantColor
          ? _value.dominantColor
          : dominantColor // ignore: cast_nullable_to_non_nullable
              as PaletteColor?,
      mutedColor: freezed == mutedColor
          ? _value.mutedColor
          : mutedColor // ignore: cast_nullable_to_non_nullable
              as PaletteColor?,
      darkMutedColor: freezed == darkMutedColor
          ? _value.darkMutedColor
          : darkMutedColor // ignore: cast_nullable_to_non_nullable
              as PaletteColor?,
      darkVibrantColor: freezed == darkVibrantColor
          ? _value.darkVibrantColor
          : darkVibrantColor // ignore: cast_nullable_to_non_nullable
              as PaletteColor?,
      lightMutedColor: freezed == lightMutedColor
          ? _value.lightMutedColor
          : lightMutedColor // ignore: cast_nullable_to_non_nullable
              as PaletteColor?,
      lightVibrantColor: freezed == lightVibrantColor
          ? _value.lightVibrantColor
          : lightVibrantColor // ignore: cast_nullable_to_non_nullable
              as PaletteColor?,
    ));
  }
}

/// @nodoc

class _$_Palette extends _Palette {
  const _$_Palette(
      {this.vibrantColor,
      this.dominantColor,
      this.mutedColor,
      this.darkMutedColor,
      this.darkVibrantColor,
      this.lightMutedColor,
      this.lightVibrantColor})
      : super._();

  @override
  final PaletteColor? vibrantColor;
  @override
  final PaletteColor? dominantColor;
  @override
  final PaletteColor? mutedColor;
  @override
  final PaletteColor? darkMutedColor;
  @override
  final PaletteColor? darkVibrantColor;
  @override
  final PaletteColor? lightMutedColor;
  @override
  final PaletteColor? lightVibrantColor;

  @override
  String toString() {
    return 'Palette(vibrantColor: $vibrantColor, dominantColor: $dominantColor, mutedColor: $mutedColor, darkMutedColor: $darkMutedColor, darkVibrantColor: $darkVibrantColor, lightMutedColor: $lightMutedColor, lightVibrantColor: $lightVibrantColor)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Palette &&
            (identical(other.vibrantColor, vibrantColor) ||
                other.vibrantColor == vibrantColor) &&
            (identical(other.dominantColor, dominantColor) ||
                other.dominantColor == dominantColor) &&
            (identical(other.mutedColor, mutedColor) ||
                other.mutedColor == mutedColor) &&
            (identical(other.darkMutedColor, darkMutedColor) ||
                other.darkMutedColor == darkMutedColor) &&
            (identical(other.darkVibrantColor, darkVibrantColor) ||
                other.darkVibrantColor == darkVibrantColor) &&
            (identical(other.lightMutedColor, lightMutedColor) ||
                other.lightMutedColor == lightMutedColor) &&
            (identical(other.lightVibrantColor, lightVibrantColor) ||
                other.lightVibrantColor == lightVibrantColor));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      vibrantColor,
      dominantColor,
      mutedColor,
      darkMutedColor,
      darkVibrantColor,
      lightMutedColor,
      lightVibrantColor);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_PaletteCopyWith<_$_Palette> get copyWith =>
      __$$_PaletteCopyWithImpl<_$_Palette>(this, _$identity);
}

abstract class _Palette extends Palette {
  const factory _Palette(
      {final PaletteColor? vibrantColor,
      final PaletteColor? dominantColor,
      final PaletteColor? mutedColor,
      final PaletteColor? darkMutedColor,
      final PaletteColor? darkVibrantColor,
      final PaletteColor? lightMutedColor,
      final PaletteColor? lightVibrantColor}) = _$_Palette;
  const _Palette._() : super._();

  @override
  PaletteColor? get vibrantColor;
  @override
  PaletteColor? get dominantColor;
  @override
  PaletteColor? get mutedColor;
  @override
  PaletteColor? get darkMutedColor;
  @override
  PaletteColor? get darkVibrantColor;
  @override
  PaletteColor? get lightMutedColor;
  @override
  PaletteColor? get lightVibrantColor;
  @override
  @JsonKey(ignore: true)
  _$$_PaletteCopyWith<_$_Palette> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ColorTheme {
  ThemeData get theme => throw _privateConstructorUsedError;
  Color get gradientHigh => throw _privateConstructorUsedError;
  Color get gradientLow => throw _privateConstructorUsedError;
  Color get darkBackground => throw _privateConstructorUsedError;
  Color get darkerBackground => throw _privateConstructorUsedError;
  Color get onDarkerBackground => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $ColorThemeCopyWith<ColorTheme> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ColorThemeCopyWith<$Res> {
  factory $ColorThemeCopyWith(
          ColorTheme value, $Res Function(ColorTheme) then) =
      _$ColorThemeCopyWithImpl<$Res, ColorTheme>;
  @useResult
  $Res call(
      {ThemeData theme,
      Color gradientHigh,
      Color gradientLow,
      Color darkBackground,
      Color darkerBackground,
      Color onDarkerBackground});
}

/// @nodoc
class _$ColorThemeCopyWithImpl<$Res, $Val extends ColorTheme>
    implements $ColorThemeCopyWith<$Res> {
  _$ColorThemeCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? theme = null,
    Object? gradientHigh = null,
    Object? gradientLow = null,
    Object? darkBackground = null,
    Object? darkerBackground = null,
    Object? onDarkerBackground = null,
  }) {
    return _then(_value.copyWith(
      theme: null == theme
          ? _value.theme
          : theme // ignore: cast_nullable_to_non_nullable
              as ThemeData,
      gradientHigh: null == gradientHigh
          ? _value.gradientHigh
          : gradientHigh // ignore: cast_nullable_to_non_nullable
              as Color,
      gradientLow: null == gradientLow
          ? _value.gradientLow
          : gradientLow // ignore: cast_nullable_to_non_nullable
              as Color,
      darkBackground: null == darkBackground
          ? _value.darkBackground
          : darkBackground // ignore: cast_nullable_to_non_nullable
              as Color,
      darkerBackground: null == darkerBackground
          ? _value.darkerBackground
          : darkerBackground // ignore: cast_nullable_to_non_nullable
              as Color,
      onDarkerBackground: null == onDarkerBackground
          ? _value.onDarkerBackground
          : onDarkerBackground // ignore: cast_nullable_to_non_nullable
              as Color,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_ColorThemeCopyWith<$Res>
    implements $ColorThemeCopyWith<$Res> {
  factory _$$_ColorThemeCopyWith(
          _$_ColorTheme value, $Res Function(_$_ColorTheme) then) =
      __$$_ColorThemeCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {ThemeData theme,
      Color gradientHigh,
      Color gradientLow,
      Color darkBackground,
      Color darkerBackground,
      Color onDarkerBackground});
}

/// @nodoc
class __$$_ColorThemeCopyWithImpl<$Res>
    extends _$ColorThemeCopyWithImpl<$Res, _$_ColorTheme>
    implements _$$_ColorThemeCopyWith<$Res> {
  __$$_ColorThemeCopyWithImpl(
      _$_ColorTheme _value, $Res Function(_$_ColorTheme) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? theme = null,
    Object? gradientHigh = null,
    Object? gradientLow = null,
    Object? darkBackground = null,
    Object? darkerBackground = null,
    Object? onDarkerBackground = null,
  }) {
    return _then(_$_ColorTheme(
      theme: null == theme
          ? _value.theme
          : theme // ignore: cast_nullable_to_non_nullable
              as ThemeData,
      gradientHigh: null == gradientHigh
          ? _value.gradientHigh
          : gradientHigh // ignore: cast_nullable_to_non_nullable
              as Color,
      gradientLow: null == gradientLow
          ? _value.gradientLow
          : gradientLow // ignore: cast_nullable_to_non_nullable
              as Color,
      darkBackground: null == darkBackground
          ? _value.darkBackground
          : darkBackground // ignore: cast_nullable_to_non_nullable
              as Color,
      darkerBackground: null == darkerBackground
          ? _value.darkerBackground
          : darkerBackground // ignore: cast_nullable_to_non_nullable
              as Color,
      onDarkerBackground: null == onDarkerBackground
          ? _value.onDarkerBackground
          : onDarkerBackground // ignore: cast_nullable_to_non_nullable
              as Color,
    ));
  }
}

/// @nodoc

class _$_ColorTheme implements _ColorTheme {
  const _$_ColorTheme(
      {required this.theme,
      required this.gradientHigh,
      required this.gradientLow,
      required this.darkBackground,
      required this.darkerBackground,
      required this.onDarkerBackground});

  @override
  final ThemeData theme;
  @override
  final Color gradientHigh;
  @override
  final Color gradientLow;
  @override
  final Color darkBackground;
  @override
  final Color darkerBackground;
  @override
  final Color onDarkerBackground;

  @override
  String toString() {
    return 'ColorTheme(theme: $theme, gradientHigh: $gradientHigh, gradientLow: $gradientLow, darkBackground: $darkBackground, darkerBackground: $darkerBackground, onDarkerBackground: $onDarkerBackground)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ColorTheme &&
            (identical(other.theme, theme) || other.theme == theme) &&
            (identical(other.gradientHigh, gradientHigh) ||
                other.gradientHigh == gradientHigh) &&
            (identical(other.gradientLow, gradientLow) ||
                other.gradientLow == gradientLow) &&
            (identical(other.darkBackground, darkBackground) ||
                other.darkBackground == darkBackground) &&
            (identical(other.darkerBackground, darkerBackground) ||
                other.darkerBackground == darkerBackground) &&
            (identical(other.onDarkerBackground, onDarkerBackground) ||
                other.onDarkerBackground == onDarkerBackground));
  }

  @override
  int get hashCode => Object.hash(runtimeType, theme, gradientHigh, gradientLow,
      darkBackground, darkerBackground, onDarkerBackground);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ColorThemeCopyWith<_$_ColorTheme> get copyWith =>
      __$$_ColorThemeCopyWithImpl<_$_ColorTheme>(this, _$identity);
}

abstract class _ColorTheme implements ColorTheme {
  const factory _ColorTheme(
      {required final ThemeData theme,
      required final Color gradientHigh,
      required final Color gradientLow,
      required final Color darkBackground,
      required final Color darkerBackground,
      required final Color onDarkerBackground}) = _$_ColorTheme;

  @override
  ThemeData get theme;
  @override
  Color get gradientHigh;
  @override
  Color get gradientLow;
  @override
  Color get darkBackground;
  @override
  Color get darkerBackground;
  @override
  Color get onDarkerBackground;
  @override
  @JsonKey(ignore: true)
  _$$_ColorThemeCopyWith<_$_ColorTheme> get copyWith =>
      throw _privateConstructorUsedError;
}

QueueItemState _$QueueItemStateFromJson(Map<String, dynamic> json) {
  return _QueueItemState.fromJson(json);
}

/// @nodoc
mixin _$QueueItemState {
  String get id => throw _privateConstructorUsedError;
  QueueContextType get contextType => throw _privateConstructorUsedError;
  String? get contextId => throw _privateConstructorUsedError;
  String? get contextTitle => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $QueueItemStateCopyWith<QueueItemState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $QueueItemStateCopyWith<$Res> {
  factory $QueueItemStateCopyWith(
          QueueItemState value, $Res Function(QueueItemState) then) =
      _$QueueItemStateCopyWithImpl<$Res, QueueItemState>;
  @useResult
  $Res call(
      {String id,
      QueueContextType contextType,
      String? contextId,
      String? contextTitle});
}

/// @nodoc
class _$QueueItemStateCopyWithImpl<$Res, $Val extends QueueItemState>
    implements $QueueItemStateCopyWith<$Res> {
  _$QueueItemStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? contextType = null,
    Object? contextId = freezed,
    Object? contextTitle = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      contextType: null == contextType
          ? _value.contextType
          : contextType // ignore: cast_nullable_to_non_nullable
              as QueueContextType,
      contextId: freezed == contextId
          ? _value.contextId
          : contextId // ignore: cast_nullable_to_non_nullable
              as String?,
      contextTitle: freezed == contextTitle
          ? _value.contextTitle
          : contextTitle // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_QueueItemStateCopyWith<$Res>
    implements $QueueItemStateCopyWith<$Res> {
  factory _$$_QueueItemStateCopyWith(
          _$_QueueItemState value, $Res Function(_$_QueueItemState) then) =
      __$$_QueueItemStateCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      QueueContextType contextType,
      String? contextId,
      String? contextTitle});
}

/// @nodoc
class __$$_QueueItemStateCopyWithImpl<$Res>
    extends _$QueueItemStateCopyWithImpl<$Res, _$_QueueItemState>
    implements _$$_QueueItemStateCopyWith<$Res> {
  __$$_QueueItemStateCopyWithImpl(
      _$_QueueItemState _value, $Res Function(_$_QueueItemState) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? contextType = null,
    Object? contextId = freezed,
    Object? contextTitle = freezed,
  }) {
    return _then(_$_QueueItemState(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      contextType: null == contextType
          ? _value.contextType
          : contextType // ignore: cast_nullable_to_non_nullable
              as QueueContextType,
      contextId: freezed == contextId
          ? _value.contextId
          : contextId // ignore: cast_nullable_to_non_nullable
              as String?,
      contextTitle: freezed == contextTitle
          ? _value.contextTitle
          : contextTitle // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_QueueItemState implements _QueueItemState {
  const _$_QueueItemState(
      {required this.id,
      required this.contextType,
      this.contextId,
      this.contextTitle});

  factory _$_QueueItemState.fromJson(Map<String, dynamic> json) =>
      _$$_QueueItemStateFromJson(json);

  @override
  final String id;
  @override
  final QueueContextType contextType;
  @override
  final String? contextId;
  @override
  final String? contextTitle;

  @override
  String toString() {
    return 'QueueItemState(id: $id, contextType: $contextType, contextId: $contextId, contextTitle: $contextTitle)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_QueueItemState &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.contextType, contextType) ||
                other.contextType == contextType) &&
            (identical(other.contextId, contextId) ||
                other.contextId == contextId) &&
            (identical(other.contextTitle, contextTitle) ||
                other.contextTitle == contextTitle));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, id, contextType, contextId, contextTitle);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_QueueItemStateCopyWith<_$_QueueItemState> get copyWith =>
      __$$_QueueItemStateCopyWithImpl<_$_QueueItemState>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_QueueItemStateToJson(
      this,
    );
  }
}

abstract class _QueueItemState implements QueueItemState {
  const factory _QueueItemState(
      {required final String id,
      required final QueueContextType contextType,
      final String? contextId,
      final String? contextTitle}) = _$_QueueItemState;

  factory _QueueItemState.fromJson(Map<String, dynamic> json) =
      _$_QueueItemState.fromJson;

  @override
  String get id;
  @override
  QueueContextType get contextType;
  @override
  String? get contextId;
  @override
  String? get contextTitle;
  @override
  @JsonKey(ignore: true)
  _$$_QueueItemStateCopyWith<_$_QueueItemState> get copyWith =>
      throw _privateConstructorUsedError;
}

MediaItemData _$MediaItemDataFromJson(Map<String, dynamic> json) {
  return _MediaItemData.fromJson(json);
}

/// @nodoc
mixin _$MediaItemData {
  int get sourceId => throw _privateConstructorUsedError;
  String? get albumId => throw _privateConstructorUsedError;
  @MediaItemArtCacheConverter()
  MediaItemArtCache? get artCache => throw _privateConstructorUsedError;
  QueueContextType get contextType => throw _privateConstructorUsedError;
  String? get contextId => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MediaItemDataCopyWith<MediaItemData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MediaItemDataCopyWith<$Res> {
  factory $MediaItemDataCopyWith(
          MediaItemData value, $Res Function(MediaItemData) then) =
      _$MediaItemDataCopyWithImpl<$Res, MediaItemData>;
  @useResult
  $Res call(
      {int sourceId,
      String? albumId,
      @MediaItemArtCacheConverter() MediaItemArtCache? artCache,
      QueueContextType contextType,
      String? contextId});

  $MediaItemArtCacheCopyWith<$Res>? get artCache;
}

/// @nodoc
class _$MediaItemDataCopyWithImpl<$Res, $Val extends MediaItemData>
    implements $MediaItemDataCopyWith<$Res> {
  _$MediaItemDataCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? sourceId = null,
    Object? albumId = freezed,
    Object? artCache = freezed,
    Object? contextType = null,
    Object? contextId = freezed,
  }) {
    return _then(_value.copyWith(
      sourceId: null == sourceId
          ? _value.sourceId
          : sourceId // ignore: cast_nullable_to_non_nullable
              as int,
      albumId: freezed == albumId
          ? _value.albumId
          : albumId // ignore: cast_nullable_to_non_nullable
              as String?,
      artCache: freezed == artCache
          ? _value.artCache
          : artCache // ignore: cast_nullable_to_non_nullable
              as MediaItemArtCache?,
      contextType: null == contextType
          ? _value.contextType
          : contextType // ignore: cast_nullable_to_non_nullable
              as QueueContextType,
      contextId: freezed == contextId
          ? _value.contextId
          : contextId // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $MediaItemArtCacheCopyWith<$Res>? get artCache {
    if (_value.artCache == null) {
      return null;
    }

    return $MediaItemArtCacheCopyWith<$Res>(_value.artCache!, (value) {
      return _then(_value.copyWith(artCache: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_MediaItemDataCopyWith<$Res>
    implements $MediaItemDataCopyWith<$Res> {
  factory _$$_MediaItemDataCopyWith(
          _$_MediaItemData value, $Res Function(_$_MediaItemData) then) =
      __$$_MediaItemDataCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int sourceId,
      String? albumId,
      @MediaItemArtCacheConverter() MediaItemArtCache? artCache,
      QueueContextType contextType,
      String? contextId});

  @override
  $MediaItemArtCacheCopyWith<$Res>? get artCache;
}

/// @nodoc
class __$$_MediaItemDataCopyWithImpl<$Res>
    extends _$MediaItemDataCopyWithImpl<$Res, _$_MediaItemData>
    implements _$$_MediaItemDataCopyWith<$Res> {
  __$$_MediaItemDataCopyWithImpl(
      _$_MediaItemData _value, $Res Function(_$_MediaItemData) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? sourceId = null,
    Object? albumId = freezed,
    Object? artCache = freezed,
    Object? contextType = null,
    Object? contextId = freezed,
  }) {
    return _then(_$_MediaItemData(
      sourceId: null == sourceId
          ? _value.sourceId
          : sourceId // ignore: cast_nullable_to_non_nullable
              as int,
      albumId: freezed == albumId
          ? _value.albumId
          : albumId // ignore: cast_nullable_to_non_nullable
              as String?,
      artCache: freezed == artCache
          ? _value.artCache
          : artCache // ignore: cast_nullable_to_non_nullable
              as MediaItemArtCache?,
      contextType: null == contextType
          ? _value.contextType
          : contextType // ignore: cast_nullable_to_non_nullable
              as QueueContextType,
      contextId: freezed == contextId
          ? _value.contextId
          : contextId // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_MediaItemData implements _MediaItemData {
  const _$_MediaItemData(
      {required this.sourceId,
      this.albumId,
      @MediaItemArtCacheConverter() this.artCache,
      required this.contextType,
      this.contextId});

  factory _$_MediaItemData.fromJson(Map<String, dynamic> json) =>
      _$$_MediaItemDataFromJson(json);

  @override
  final int sourceId;
  @override
  final String? albumId;
  @override
  @MediaItemArtCacheConverter()
  final MediaItemArtCache? artCache;
  @override
  final QueueContextType contextType;
  @override
  final String? contextId;

  @override
  String toString() {
    return 'MediaItemData(sourceId: $sourceId, albumId: $albumId, artCache: $artCache, contextType: $contextType, contextId: $contextId)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_MediaItemData &&
            (identical(other.sourceId, sourceId) ||
                other.sourceId == sourceId) &&
            (identical(other.albumId, albumId) || other.albumId == albumId) &&
            (identical(other.artCache, artCache) ||
                other.artCache == artCache) &&
            (identical(other.contextType, contextType) ||
                other.contextType == contextType) &&
            (identical(other.contextId, contextId) ||
                other.contextId == contextId));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, sourceId, albumId, artCache, contextType, contextId);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_MediaItemDataCopyWith<_$_MediaItemData> get copyWith =>
      __$$_MediaItemDataCopyWithImpl<_$_MediaItemData>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_MediaItemDataToJson(
      this,
    );
  }
}

abstract class _MediaItemData implements MediaItemData {
  const factory _MediaItemData(
      {required final int sourceId,
      final String? albumId,
      @MediaItemArtCacheConverter() final MediaItemArtCache? artCache,
      required final QueueContextType contextType,
      final String? contextId}) = _$_MediaItemData;

  factory _MediaItemData.fromJson(Map<String, dynamic> json) =
      _$_MediaItemData.fromJson;

  @override
  int get sourceId;
  @override
  String? get albumId;
  @override
  @MediaItemArtCacheConverter()
  MediaItemArtCache? get artCache;
  @override
  QueueContextType get contextType;
  @override
  String? get contextId;
  @override
  @JsonKey(ignore: true)
  _$$_MediaItemDataCopyWith<_$_MediaItemData> get copyWith =>
      throw _privateConstructorUsedError;
}

MediaItemArtCache _$MediaItemArtCacheFromJson(Map<String, dynamic> json) {
  return _MediaItemArtCache.fromJson(json);
}

/// @nodoc
mixin _$MediaItemArtCache {
  Uri get fullArtUri => throw _privateConstructorUsedError;
  String get fullArtCacheKey => throw _privateConstructorUsedError;
  Uri get thumbnailArtUri => throw _privateConstructorUsedError;
  String get thumbnailArtCacheKey => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MediaItemArtCacheCopyWith<MediaItemArtCache> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MediaItemArtCacheCopyWith<$Res> {
  factory $MediaItemArtCacheCopyWith(
          MediaItemArtCache value, $Res Function(MediaItemArtCache) then) =
      _$MediaItemArtCacheCopyWithImpl<$Res, MediaItemArtCache>;
  @useResult
  $Res call(
      {Uri fullArtUri,
      String fullArtCacheKey,
      Uri thumbnailArtUri,
      String thumbnailArtCacheKey});
}

/// @nodoc
class _$MediaItemArtCacheCopyWithImpl<$Res, $Val extends MediaItemArtCache>
    implements $MediaItemArtCacheCopyWith<$Res> {
  _$MediaItemArtCacheCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fullArtUri = null,
    Object? fullArtCacheKey = null,
    Object? thumbnailArtUri = null,
    Object? thumbnailArtCacheKey = null,
  }) {
    return _then(_value.copyWith(
      fullArtUri: null == fullArtUri
          ? _value.fullArtUri
          : fullArtUri // ignore: cast_nullable_to_non_nullable
              as Uri,
      fullArtCacheKey: null == fullArtCacheKey
          ? _value.fullArtCacheKey
          : fullArtCacheKey // ignore: cast_nullable_to_non_nullable
              as String,
      thumbnailArtUri: null == thumbnailArtUri
          ? _value.thumbnailArtUri
          : thumbnailArtUri // ignore: cast_nullable_to_non_nullable
              as Uri,
      thumbnailArtCacheKey: null == thumbnailArtCacheKey
          ? _value.thumbnailArtCacheKey
          : thumbnailArtCacheKey // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_MediaItemArtCacheCopyWith<$Res>
    implements $MediaItemArtCacheCopyWith<$Res> {
  factory _$$_MediaItemArtCacheCopyWith(_$_MediaItemArtCache value,
          $Res Function(_$_MediaItemArtCache) then) =
      __$$_MediaItemArtCacheCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {Uri fullArtUri,
      String fullArtCacheKey,
      Uri thumbnailArtUri,
      String thumbnailArtCacheKey});
}

/// @nodoc
class __$$_MediaItemArtCacheCopyWithImpl<$Res>
    extends _$MediaItemArtCacheCopyWithImpl<$Res, _$_MediaItemArtCache>
    implements _$$_MediaItemArtCacheCopyWith<$Res> {
  __$$_MediaItemArtCacheCopyWithImpl(
      _$_MediaItemArtCache _value, $Res Function(_$_MediaItemArtCache) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fullArtUri = null,
    Object? fullArtCacheKey = null,
    Object? thumbnailArtUri = null,
    Object? thumbnailArtCacheKey = null,
  }) {
    return _then(_$_MediaItemArtCache(
      fullArtUri: null == fullArtUri
          ? _value.fullArtUri
          : fullArtUri // ignore: cast_nullable_to_non_nullable
              as Uri,
      fullArtCacheKey: null == fullArtCacheKey
          ? _value.fullArtCacheKey
          : fullArtCacheKey // ignore: cast_nullable_to_non_nullable
              as String,
      thumbnailArtUri: null == thumbnailArtUri
          ? _value.thumbnailArtUri
          : thumbnailArtUri // ignore: cast_nullable_to_non_nullable
              as Uri,
      thumbnailArtCacheKey: null == thumbnailArtCacheKey
          ? _value.thumbnailArtCacheKey
          : thumbnailArtCacheKey // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_MediaItemArtCache implements _MediaItemArtCache {
  const _$_MediaItemArtCache(
      {required this.fullArtUri,
      required this.fullArtCacheKey,
      required this.thumbnailArtUri,
      required this.thumbnailArtCacheKey});

  factory _$_MediaItemArtCache.fromJson(Map<String, dynamic> json) =>
      _$$_MediaItemArtCacheFromJson(json);

  @override
  final Uri fullArtUri;
  @override
  final String fullArtCacheKey;
  @override
  final Uri thumbnailArtUri;
  @override
  final String thumbnailArtCacheKey;

  @override
  String toString() {
    return 'MediaItemArtCache(fullArtUri: $fullArtUri, fullArtCacheKey: $fullArtCacheKey, thumbnailArtUri: $thumbnailArtUri, thumbnailArtCacheKey: $thumbnailArtCacheKey)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_MediaItemArtCache &&
            (identical(other.fullArtUri, fullArtUri) ||
                other.fullArtUri == fullArtUri) &&
            (identical(other.fullArtCacheKey, fullArtCacheKey) ||
                other.fullArtCacheKey == fullArtCacheKey) &&
            (identical(other.thumbnailArtUri, thumbnailArtUri) ||
                other.thumbnailArtUri == thumbnailArtUri) &&
            (identical(other.thumbnailArtCacheKey, thumbnailArtCacheKey) ||
                other.thumbnailArtCacheKey == thumbnailArtCacheKey));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, fullArtUri, fullArtCacheKey,
      thumbnailArtUri, thumbnailArtCacheKey);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_MediaItemArtCacheCopyWith<_$_MediaItemArtCache> get copyWith =>
      __$$_MediaItemArtCacheCopyWithImpl<_$_MediaItemArtCache>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_MediaItemArtCacheToJson(
      this,
    );
  }
}

abstract class _MediaItemArtCache implements MediaItemArtCache {
  const factory _MediaItemArtCache(
      {required final Uri fullArtUri,
      required final String fullArtCacheKey,
      required final Uri thumbnailArtUri,
      required final String thumbnailArtCacheKey}) = _$_MediaItemArtCache;

  factory _MediaItemArtCache.fromJson(Map<String, dynamic> json) =
      _$_MediaItemArtCache.fromJson;

  @override
  Uri get fullArtUri;
  @override
  String get fullArtCacheKey;
  @override
  Uri get thumbnailArtUri;
  @override
  String get thumbnailArtCacheKey;
  @override
  @JsonKey(ignore: true)
  _$$_MediaItemArtCacheCopyWith<_$_MediaItemArtCache> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ListDownloadStatus {
  int get total => throw _privateConstructorUsedError;
  int get downloaded => throw _privateConstructorUsedError;
  int get downloading => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $ListDownloadStatusCopyWith<ListDownloadStatus> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ListDownloadStatusCopyWith<$Res> {
  factory $ListDownloadStatusCopyWith(
          ListDownloadStatus value, $Res Function(ListDownloadStatus) then) =
      _$ListDownloadStatusCopyWithImpl<$Res, ListDownloadStatus>;
  @useResult
  $Res call({int total, int downloaded, int downloading});
}

/// @nodoc
class _$ListDownloadStatusCopyWithImpl<$Res, $Val extends ListDownloadStatus>
    implements $ListDownloadStatusCopyWith<$Res> {
  _$ListDownloadStatusCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? total = null,
    Object? downloaded = null,
    Object? downloading = null,
  }) {
    return _then(_value.copyWith(
      total: null == total
          ? _value.total
          : total // ignore: cast_nullable_to_non_nullable
              as int,
      downloaded: null == downloaded
          ? _value.downloaded
          : downloaded // ignore: cast_nullable_to_non_nullable
              as int,
      downloading: null == downloading
          ? _value.downloading
          : downloading // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_ListDownloadStatusCopyWith<$Res>
    implements $ListDownloadStatusCopyWith<$Res> {
  factory _$$_ListDownloadStatusCopyWith(_$_ListDownloadStatus value,
          $Res Function(_$_ListDownloadStatus) then) =
      __$$_ListDownloadStatusCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int total, int downloaded, int downloading});
}

/// @nodoc
class __$$_ListDownloadStatusCopyWithImpl<$Res>
    extends _$ListDownloadStatusCopyWithImpl<$Res, _$_ListDownloadStatus>
    implements _$$_ListDownloadStatusCopyWith<$Res> {
  __$$_ListDownloadStatusCopyWithImpl(
      _$_ListDownloadStatus _value, $Res Function(_$_ListDownloadStatus) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? total = null,
    Object? downloaded = null,
    Object? downloading = null,
  }) {
    return _then(_$_ListDownloadStatus(
      total: null == total
          ? _value.total
          : total // ignore: cast_nullable_to_non_nullable
              as int,
      downloaded: null == downloaded
          ? _value.downloaded
          : downloaded // ignore: cast_nullable_to_non_nullable
              as int,
      downloading: null == downloading
          ? _value.downloading
          : downloading // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$_ListDownloadStatus implements _ListDownloadStatus {
  const _$_ListDownloadStatus(
      {required this.total,
      required this.downloaded,
      required this.downloading});

  @override
  final int total;
  @override
  final int downloaded;
  @override
  final int downloading;

  @override
  String toString() {
    return 'ListDownloadStatus(total: $total, downloaded: $downloaded, downloading: $downloading)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ListDownloadStatus &&
            (identical(other.total, total) || other.total == total) &&
            (identical(other.downloaded, downloaded) ||
                other.downloaded == downloaded) &&
            (identical(other.downloading, downloading) ||
                other.downloading == downloading));
  }

  @override
  int get hashCode => Object.hash(runtimeType, total, downloaded, downloading);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ListDownloadStatusCopyWith<_$_ListDownloadStatus> get copyWith =>
      __$$_ListDownloadStatusCopyWithImpl<_$_ListDownloadStatus>(
          this, _$identity);
}

abstract class _ListDownloadStatus implements ListDownloadStatus {
  const factory _ListDownloadStatus(
      {required final int total,
      required final int downloaded,
      required final int downloading}) = _$_ListDownloadStatus;

  @override
  int get total;
  @override
  int get downloaded;
  @override
  int get downloading;
  @override
  @JsonKey(ignore: true)
  _$$_ListDownloadStatusCopyWith<_$_ListDownloadStatus> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$MultiChoiceOption {
  String get title => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(String title) $default, {
    required TResult Function(String title, int option) int,
    required TResult Function(String title, String option) string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(String title)? $default, {
    TResult? Function(String title, int option)? int,
    TResult? Function(String title, String option)? string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(String title)? $default, {
    TResult Function(String title, int option)? int,
    TResult Function(String title, String option)? string,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_MultiChoiceOption value) $default, {
    required TResult Function(_MultiChoiceOptionInt value) int,
    required TResult Function(_MultiChoiceOptionString value) string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_MultiChoiceOption value)? $default, {
    TResult? Function(_MultiChoiceOptionInt value)? int,
    TResult? Function(_MultiChoiceOptionString value)? string,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_MultiChoiceOption value)? $default, {
    TResult Function(_MultiChoiceOptionInt value)? int,
    TResult Function(_MultiChoiceOptionString value)? string,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $MultiChoiceOptionCopyWith<MultiChoiceOption> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MultiChoiceOptionCopyWith<$Res> {
  factory $MultiChoiceOptionCopyWith(
          MultiChoiceOption value, $Res Function(MultiChoiceOption) then) =
      _$MultiChoiceOptionCopyWithImpl<$Res, MultiChoiceOption>;
  @useResult
  $Res call({String title});
}

/// @nodoc
class _$MultiChoiceOptionCopyWithImpl<$Res, $Val extends MultiChoiceOption>
    implements $MultiChoiceOptionCopyWith<$Res> {
  _$MultiChoiceOptionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? title = null,
  }) {
    return _then(_value.copyWith(
      title: null == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_MultiChoiceOptionCopyWith<$Res>
    implements $MultiChoiceOptionCopyWith<$Res> {
  factory _$$_MultiChoiceOptionCopyWith(_$_MultiChoiceOption value,
          $Res Function(_$_MultiChoiceOption) then) =
      __$$_MultiChoiceOptionCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String title});
}

/// @nodoc
class __$$_MultiChoiceOptionCopyWithImpl<$Res>
    extends _$MultiChoiceOptionCopyWithImpl<$Res, _$_MultiChoiceOption>
    implements _$$_MultiChoiceOptionCopyWith<$Res> {
  __$$_MultiChoiceOptionCopyWithImpl(
      _$_MultiChoiceOption _value, $Res Function(_$_MultiChoiceOption) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? title = null,
  }) {
    return _then(_$_MultiChoiceOption(
      title: null == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_MultiChoiceOption implements _MultiChoiceOption {
  const _$_MultiChoiceOption({required this.title});

  @override
  final String title;

  @override
  String toString() {
    return 'MultiChoiceOption(title: $title)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_MultiChoiceOption &&
            (identical(other.title, title) || other.title == title));
  }

  @override
  int get hashCode => Object.hash(runtimeType, title);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_MultiChoiceOptionCopyWith<_$_MultiChoiceOption> get copyWith =>
      __$$_MultiChoiceOptionCopyWithImpl<_$_MultiChoiceOption>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(String title) $default, {
    required TResult Function(String title, int option) int,
    required TResult Function(String title, String option) string,
  }) {
    return $default(title);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(String title)? $default, {
    TResult? Function(String title, int option)? int,
    TResult? Function(String title, String option)? string,
  }) {
    return $default?.call(title);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(String title)? $default, {
    TResult Function(String title, int option)? int,
    TResult Function(String title, String option)? string,
    required TResult orElse(),
  }) {
    if ($default != null) {
      return $default(title);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_MultiChoiceOption value) $default, {
    required TResult Function(_MultiChoiceOptionInt value) int,
    required TResult Function(_MultiChoiceOptionString value) string,
  }) {
    return $default(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_MultiChoiceOption value)? $default, {
    TResult? Function(_MultiChoiceOptionInt value)? int,
    TResult? Function(_MultiChoiceOptionString value)? string,
  }) {
    return $default?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_MultiChoiceOption value)? $default, {
    TResult Function(_MultiChoiceOptionInt value)? int,
    TResult Function(_MultiChoiceOptionString value)? string,
    required TResult orElse(),
  }) {
    if ($default != null) {
      return $default(this);
    }
    return orElse();
  }
}

abstract class _MultiChoiceOption implements MultiChoiceOption {
  const factory _MultiChoiceOption({required final String title}) =
      _$_MultiChoiceOption;

  @override
  String get title;
  @override
  @JsonKey(ignore: true)
  _$$_MultiChoiceOptionCopyWith<_$_MultiChoiceOption> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_MultiChoiceOptionIntCopyWith<$Res>
    implements $MultiChoiceOptionCopyWith<$Res> {
  factory _$$_MultiChoiceOptionIntCopyWith(_$_MultiChoiceOptionInt value,
          $Res Function(_$_MultiChoiceOptionInt) then) =
      __$$_MultiChoiceOptionIntCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String title, int option});
}

/// @nodoc
class __$$_MultiChoiceOptionIntCopyWithImpl<$Res>
    extends _$MultiChoiceOptionCopyWithImpl<$Res, _$_MultiChoiceOptionInt>
    implements _$$_MultiChoiceOptionIntCopyWith<$Res> {
  __$$_MultiChoiceOptionIntCopyWithImpl(_$_MultiChoiceOptionInt _value,
      $Res Function(_$_MultiChoiceOptionInt) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? title = null,
    Object? option = null,
  }) {
    return _then(_$_MultiChoiceOptionInt(
      title: null == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
      option: null == option
          ? _value.option
          : option // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$_MultiChoiceOptionInt implements _MultiChoiceOptionInt {
  _$_MultiChoiceOptionInt({required this.title, required this.option});

  @override
  final String title;
  @override
  final int option;

  @override
  String toString() {
    return 'MultiChoiceOption.int(title: $title, option: $option)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_MultiChoiceOptionInt &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.option, option) || other.option == option));
  }

  @override
  int get hashCode => Object.hash(runtimeType, title, option);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_MultiChoiceOptionIntCopyWith<_$_MultiChoiceOptionInt> get copyWith =>
      __$$_MultiChoiceOptionIntCopyWithImpl<_$_MultiChoiceOptionInt>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(String title) $default, {
    required TResult Function(String title, int option) int,
    required TResult Function(String title, String option) string,
  }) {
    return int(title, option);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(String title)? $default, {
    TResult? Function(String title, int option)? int,
    TResult? Function(String title, String option)? string,
  }) {
    return int?.call(title, option);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(String title)? $default, {
    TResult Function(String title, int option)? int,
    TResult Function(String title, String option)? string,
    required TResult orElse(),
  }) {
    if (int != null) {
      return int(title, option);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_MultiChoiceOption value) $default, {
    required TResult Function(_MultiChoiceOptionInt value) int,
    required TResult Function(_MultiChoiceOptionString value) string,
  }) {
    return int(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_MultiChoiceOption value)? $default, {
    TResult? Function(_MultiChoiceOptionInt value)? int,
    TResult? Function(_MultiChoiceOptionString value)? string,
  }) {
    return int?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_MultiChoiceOption value)? $default, {
    TResult Function(_MultiChoiceOptionInt value)? int,
    TResult Function(_MultiChoiceOptionString value)? string,
    required TResult orElse(),
  }) {
    if (int != null) {
      return int(this);
    }
    return orElse();
  }
}

abstract class _MultiChoiceOptionInt implements MultiChoiceOption {
  factory _MultiChoiceOptionInt(
      {required final String title,
      required final int option}) = _$_MultiChoiceOptionInt;

  @override
  String get title;
  int get option;
  @override
  @JsonKey(ignore: true)
  _$$_MultiChoiceOptionIntCopyWith<_$_MultiChoiceOptionInt> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_MultiChoiceOptionStringCopyWith<$Res>
    implements $MultiChoiceOptionCopyWith<$Res> {
  factory _$$_MultiChoiceOptionStringCopyWith(_$_MultiChoiceOptionString value,
          $Res Function(_$_MultiChoiceOptionString) then) =
      __$$_MultiChoiceOptionStringCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String title, String option});
}

/// @nodoc
class __$$_MultiChoiceOptionStringCopyWithImpl<$Res>
    extends _$MultiChoiceOptionCopyWithImpl<$Res, _$_MultiChoiceOptionString>
    implements _$$_MultiChoiceOptionStringCopyWith<$Res> {
  __$$_MultiChoiceOptionStringCopyWithImpl(_$_MultiChoiceOptionString _value,
      $Res Function(_$_MultiChoiceOptionString) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? title = null,
    Object? option = null,
  }) {
    return _then(_$_MultiChoiceOptionString(
      title: null == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
      option: null == option
          ? _value.option
          : option // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_MultiChoiceOptionString implements _MultiChoiceOptionString {
  _$_MultiChoiceOptionString({required this.title, required this.option});

  @override
  final String title;
  @override
  final String option;

  @override
  String toString() {
    return 'MultiChoiceOption.string(title: $title, option: $option)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_MultiChoiceOptionString &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.option, option) || other.option == option));
  }

  @override
  int get hashCode => Object.hash(runtimeType, title, option);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_MultiChoiceOptionStringCopyWith<_$_MultiChoiceOptionString>
      get copyWith =>
          __$$_MultiChoiceOptionStringCopyWithImpl<_$_MultiChoiceOptionString>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(String title) $default, {
    required TResult Function(String title, int option) int,
    required TResult Function(String title, String option) string,
  }) {
    return string(title, option);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(String title)? $default, {
    TResult? Function(String title, int option)? int,
    TResult? Function(String title, String option)? string,
  }) {
    return string?.call(title, option);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(String title)? $default, {
    TResult Function(String title, int option)? int,
    TResult Function(String title, String option)? string,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(title, option);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_MultiChoiceOption value) $default, {
    required TResult Function(_MultiChoiceOptionInt value) int,
    required TResult Function(_MultiChoiceOptionString value) string,
  }) {
    return string(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_MultiChoiceOption value)? $default, {
    TResult? Function(_MultiChoiceOptionInt value)? int,
    TResult? Function(_MultiChoiceOptionString value)? string,
  }) {
    return string?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_MultiChoiceOption value)? $default, {
    TResult Function(_MultiChoiceOptionInt value)? int,
    TResult Function(_MultiChoiceOptionString value)? string,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(this);
    }
    return orElse();
  }
}

abstract class _MultiChoiceOptionString implements MultiChoiceOption {
  factory _MultiChoiceOptionString(
      {required final String title,
      required final String option}) = _$_MultiChoiceOptionString;

  @override
  String get title;
  String get option;
  @override
  @JsonKey(ignore: true)
  _$$_MultiChoiceOptionStringCopyWith<_$_MultiChoiceOptionString>
      get copyWith => throw _privateConstructorUsedError;
}
